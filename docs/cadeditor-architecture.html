<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-dark.css" media="screen">

    <title>Архитектура редактора CadEditor</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>Архитектура редактора CadEditor</h1>
        <h2>Устройство формата уровня</h2>
      </div>
    </header>

    <div class="container">
      <section id="main_content">

<p>      
Привет всем читающим.
</p>

<p>
В этой статье я попробую изложить основные принципы и идеи реализации универсального блочного редактора уровней, который можно будет использовать с разными играми, внутренний формат хранения данных в которых не известен заранее. Данные принципы частично реализованы в редакторе уровней <a href="https://github.com/spiiin/CadEditor">CadEditor</a>, в котором в данный момент можно редактировать уровни из около 100 различных игр на NES и Sega Mega Drive (а также возможно подключение других игр без изменения кода редактора).
</p>

<p>
Но надо учитывать, что редактор изначально создавался для игры <b>Chip and Dale</b> (<b>CaD</b> Editor), и момент создания я знал только о формате уровней этой игры, и лишь потом поверх этого в него постепенно добавлялись фичи, позволяющие описывать уровни в других играх, поэтому код местами наполнен костылями, от которых надо избавиться, выкинув устаревшие части и заменив их более общими идеями.
</p>

<h2><a id="princ" class="anchor" href="#princ" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Принципы работы простых блочных редакторов</h2>

<p>
В самом простом случае блочный редактор представляет собой всего пару окон - в одном из которых пользователь выбирает активный блок, а в другом - рисует выбранным блоком по карте уровня.
</p>

<p>
Часто помимо самой рисования блоков на карте пользователю даётся возможность расставлять в по ней объекты и сохранять список этих объектов и их свойств в отдельный файл, либо же вместе с массивом индексов блоков (в этом случае уже необходимо какое-либо формальное описание формата файла с картой).

Также в формат уровня обычно входят какие-либо параметры карты, вроде используемного набора блоков в этой карте, а также её размеры и структура входов и выходов из карты.

Почти все редакторы работают с каким-либо конкретным форматом карты, в лучшем случае позволяют экспортировать/импортировать карты в несколько различных форматов. Например, редактор Tiled позволяет сохранять карту в формат tmx, для которого есть загрузчики для различных игровых движков, а также экспортировать её в формат для других редакторов карт.
<img src="images/tut3_tiled_felix.png" alt="tiled">
</p>

<p>
Однако разные игры могут очень сильно отличаться по форматам данных, которые используются для внутреннего хранения информации об уровнях. Если разработчик создаёт собственную игру, он может использовать тот формат, в котором сохраняет карты имеющийся редактор уровней.
</p>

<p>
Но как поступить в обратной ситуации, когда игра уже создана и формат уровней в ней известен, а редактора уровней для неё в открытом доступе нет?
</p>

<p>
Существует три пути решения этой проблемы:

<ul>
<li>Можно <b>написать редактор уровней с нуля для конкретной игры</b>. <p>Плюс этого подхода - редактор гарантировано будет учитывать все особенности конкретной игры и подстроен под её ограничения. Минусы - каждый раз с нуля писать редакторы долго и непродуктивно, существуют сотни старых игр с множеством фанатов, делать редактор для каждой отдельно долго и сложно. Кроме того, будет очень сложно поддерживать все эти редакторы. Например, если возникнет желание добавить возможность отмены последнего действия пользователя, придётся вносить её в каждый редактор. Необходимо использовать какой-либо "каркас" с общими для всех редакторов функциями - отображение координатной сетки, очистка всей карты, контекстной меню, оптимизация рендеринга больших карт, масштаб - и т.д. и т.п.</p></li><br>

<li><b>Использование готового тайлового редактора</b> и создание уровня в нём, а затем конвертация уровня в свой формат. <p>Этот подход лишён минусов предыдущего - готовая программа скорее всего обладает всем необходимым функционалом по редактированию, и после создания уровня остаётся только задача по конвертации готовой карты в свой формат. Однако, если вы попробуете сделать подобное на практике, то скорее всего столкнётесь с двумя проблемами, вытекающими из того,  что все готовые редакторы уровней работают с картой своего формата, и не позволяют описывать какие-либо дополнительные ОГРАНИЧЕНИЯ, а также как-либо существенно менять этот формат. Первая проблема - отличия между форматом карт редактора и нужной вам игры могут быть несколько велики, что конвертер будет очень сложным. Вторая проблема - если созданный в редакторе уровень оказалось невозможно конвертировать в уровень для игры - очень сложно внятно объяснить пользователю, почему его прекрасный уровень не годится и его надо упростить и как именно ему это нужно сделать. Простейший пример - игра может использовать для хранения индексов блоков 1 байт, и это означает, что пользователь должен ограничить себя 256 блоками, более сложные могут включать в себя сложные условые на порядок расположения объектов для игрового движка, количество используемых цветов и итоговый размер файла карты после конвертации.</p></li><br>

<li><b>Создание универсального редактора</b>, который позволит гибко задать ограничения для любой игры. <p>Минусы данного подхода - в общем виде данная задача очень сложная (нужно предусмотреть все возможные варианты того, что приходило в голову разработчикам игр всех времён), любая неучтённая мелочь может обернуться невозможность использовать редактор с какой-либо игрой, или использовать лишь частично. Плюсы - если ограничить себя отдельной категорией игр, то можно достичь хороших результатов, причём неучтённые особенности можно добавлять по мере развития и поддержки такого супер-редактора.</p></li><br>
</ul>
<p>

<p>
В категорию игр, которую я выбрал для редактора CadEditor, попадают почти все игры для старых консолей - <b>NES, SNES, Game Boy, Game Boy Advance, Sega Mega Drive</b>, скорее всего другие платформы с тайловой графикой.
</p>

<h2><a id="obshch" class="anchor" href="#obshch" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Общие идеи, встречающиеся в большинстве игр с блочными картами</h2>

<p>
Большинство форматов игр я исследовал с помощью реверс-инжиниринга игр для <b>NES</b> (и немного для <b>SMD</b> и <b>GBA</b>), для других игр я изучал документацию, сделанную другими исследователями и читал код их редакторов уровней. Я думаю, что перебрал форматы игр около 150 игр, на основании которых составил заметки о том, как создать такие строительные элементы, с помощью которых можно составить уровни к каждой из игр.
</p>

<p>
Сначала я опишу эти базовые строительные элементы, "кирпичики", из которых можно построить уровень. Они выбраны так, чтобы с помощью них можно было описать максимально широкий диапазон уровней, поэтому для простых игр они могут показаться избыточными, однако только с помощью всех них вместе можно описать любую (теоретически) игру и добавить её в редактор.
</p>

<p>
После описания этих элементов, я покажу, какие способы описания взаимоотношений элементов можно дать пользователю (описывать их комбинации и настройки, задавать ограничения и разрешения на добавления новых элементов динамически, а также указывать допустимые способы сохранения/загрузки в файлы).
</p>

<p>
В следующих статьях будет подробно разобрана структура нескольких игр, и будет описано, как с помощью строительных элементов передать эту структуру для редактора <b>CadEditor</b>.
</p>

<h3>Layout</h3>
<p>
<img src="images/tut3_cad_editor_enemies.png" alt="objec lists">
<i>редактор списка объектов в раскладке</i><br><br>
Самым общим понятием редактора уровня является "раскладка" уровня (<b>Layout</b>). Этот элемент описывает, каким образом соединяются вместе "экраны" (<b>ScreensList</b>), а также описывает свойства уровня (<b>Params</b>) и списки объектов (<b>OjbectsList</b>) на нём.
</p>

<h4>ScreensList</h4> 
<p>
Список экранов, элементы которого - "экраны" (<b>Screen</b>). В общем случае в раскладке указывается, как именно соединяются экраны вместе. В 99% случаев это матрица, в которую вписаны номера экранов, а также указаны произвольные свойства для этих экранов (уникальные для каждой игры, сюда может входить информация о направлении движения, спецэффектах, активирующих на данных экране, расположенных на них выходах с уровня и телепортах и т.п.).
</p>
<p>
Однако, кроме матрицы из экранов одинакового размера это может быть также список, в котором хранятся координаты левого верхнего угла экранов, при этом экраны могут быть разного размера в пределах одной раскладки. Матрица экранов - это просто частный случай такого списка, в котором все экраны одного размера и находятся на одинаковом расстоянии друг от друга. Свойства экрана могут быть привязаны как конкретному экрану, так и к элементу списка, в котором он хранится (тогда, например, два одинаковых экрана могут иметь разные свойства, хотя и быть визуально идентичными). В простейшем случае список экранов хранит лишь один глобальный экран, который предствяет из себя целый уровень, в других случаях экран - это какая-либо часть уровня.
</p>

<h4>Params</h4>
<p>
Обобщённый список свойств уровня, сюда может входить любая информация, в зависимости от игры (название уровня, его размер, допустимое количество объектов, используемые мелодии и звуки, стартовая точка, чекпоинты и т.п.). Свойства данного списка могут быть как простыми (числа, строки, другие списки), так и сложными. В этом случае для их редактирования могут подключаться плагины-редакторы свойств. Примеры таких свойств: редактор траектории камеры на всём уровне (<b>Adventure Island 1</b>), редактор препятствий на трассе (<b>Battletoads</b>), изометрический редактор высоты уровня (<b>Final Fantasy Tactics Advance</b>) и другие.
</p>

<h4>ObjectsList</h4>
<p>
Массив из одного или нескольких списков объектов расставленных на уровне. В самом общем случае объект в списке может иметь некоторый идентификатор, и координаты на уровне (номер или координату в списке экранов и позицию на экране), а также список из произвольных свойств объекта. Сам объект может представлять собой любой элемент уровня, отображается или невидимый на экране - стартовую позицию игрока, врага, приз, выход из уровня или триггер, меняющий музыку или палитру экрана). Главное отличие списка объектов от списка свойств уровня - он имеет отношение к какому-либо игровому экрану, а не относится ко всему уровню в целом. Списки объектов могут содержать однородные или разнородные объекты (например, в одном списке могут хранится как враги, так и игровые события, срабатывающие при определённых условиях).
</p>

<h3>Screen</h3>
<p>
<img src="images/tut3_cad_editor_main.png" alt="screend">
<i>редактор слоя тайлов на экране</i><br><br>

Логическая единица, представляющая собой прямоугольную часть уровня, которая соединяет несколько "слоёв" блоков (<b>BlocksLayer</b>). Стоит отметить, что никаких ограничений на размер нет, экраны могут быть огромных размеров в тысячи блоков, так и состоять из 1 блока в ширину и высоту, логический смысл данного строительного элемента лишь в том, что он может объединять несколько слоёв один поверх другого. В тривиальном случае экран содержит один слой. 
</p>
<p>
Другое замечание - экран пока что описывается только как прямоугольник, отсутствует возможность задавать изометрические или гексагональные экраны и слои, ввиду того, что для приставок с тайловой графикой, родным строительным элементом для старых консолей является тайл, который может быть выведен только в виде прямоугольника на экране. Если логически в игре используется изометрическая сетка, то её элементами будут не тайлы, и её можно описать и отредактировать подредактором в <b>Params</b> в <b>Layout</b> уровня.
</p>

<h4>Params</h4>
<p>Также для экрана, как и для <b>Layout</b>, и для всех остальных строительных элементов, можно описать массив произвольных свойств <b>Params</b>, в который будут читаться и сохраняться свойства экрана для конкретной игры, если это необходимо. Разные игры могут хранить свойства на разных логических уровнях (например, номер мелодии или погодного эффекта может сохраняться для всего уровня, или для конкретного экрана), и редактор должен позволять описывать эти свойства так, как это необходимо для конкретной игры. Для последующих логических блоков я буду просто указывать наличие данного свойства.</p>

<h4>BlockLayer</h4>
<p>
Слой из блоков (<b>Block</b>). Слой представляет собой массив из блоков (<b>Block</b>) одного типа. Может быть смещён относительно начала экрана, если это необходимо. Также содержит описание формы заполнения слоя блоками (например, сверху-вниз или слева-направо).
</p>

<h3>Block</h3>
<p>
<img src="images/tut3_cad_editor_bigblocks2.png" alt="blocks">
<i>редактор блоков</i><br><br>
Состоит из матрицы <b>Indexes</b>, элементами которой являются индексы блоков (<b>Block</b>) или тайлов (<b>Tile</b>), а также произвольные свойства (<b>Params</b>). Блоки могут состоять из других блоков, таким образом могут быть описаны иерархические структуры. Например, часто встречается структура экрана, при которой он описывается слоем макроблоков размером 2x2, каждый из которых сам состоит из 2x2 блоков, каждый из которых состоит из 2x2 тайлов. Это позволяет описывать экран очень компактно.
</p>

<p>
Вместо массива индексов существует возможность указать предзаготовленную картинку (<b>BlockPicture</b>), которая будет использоваться для отображения блока. Эта возможность полезна, если неизвестен формат, из которого построен блок. Если блок состоит из более мелких блоков, то он также содержит указатель на массив более мелких блоков, из которых будет строиться блок (<b>SubblocksPointer</b>).

<h4>SubblocksPointer</h4>
<p>
Указатель на массив более мелких блоков, из которых состоит блок. Используется в случае, если блок состоит не из тайлов, а из более мелких блоков.
</p>

<h4>Indexes</h4>
<p>
Массив индексов блоков или тайлов, из которых состоит блок.
</p>

<h4>Pictures</h4>
<p>
Изображение блока. Задаётся вместо массива индексов, если по каким-либо причинам пользователь не имеет возможности описать, из каких более мелких единиц состоит блок.
</p>

<h4>Params</h4>
<p>
Часто блоки содержат параметры, определяющие физические свойства блока (его проходимость в игре), описание палитры.
</p>

<h3>Brush</h3>
<p>
Иногда требуется ограничить возможность пользователя рисовать отдельными блоками, и разрешить ему использовать только определённые группы блоков вместе. В этом случае можно описать "Кисти" (<b>Brush</b>), состоящие из наборов блоков, которые можно устанавливать на карте только вместе, или с соблюдением дополнительных ограничений, и задать дополнительные параметры кистей. Возможность пока не реализована в редакторе.
</p>

<h3>Tiles</h3>
<p>
<img src="images/tut3_cad_editor_chr_editor.png" alt="tiles">
<i>просмотрщик построенных тайлов</i><br><br>
Самая мелкая единица построения уровня. Тайлы - это картинки (загруженная или построеннык каким-либо способом), из которых строятся блоки.
</p>

<h3>Взаимоотношение элементов формата уровня</h3>
<p>
В итоге получается примерно такая схема отношений элементов:
<img src="images/tut3_level_format_elements.png" alt="tiled">
</p>


<h2>Задание описания формата уровней для подключения новой игры к редактору</h2>

<p>
Для того, чтобы подключить к универсальному редактору новую игру, необходимо:
</p>
<p>
<ol>
<li>
Описать взаимоотношения между элементами для конкретной игры - указать, параметры раскладки, из каких экранов она состоит и какие в ней есть списки объектов, далее описать сколько и какие слои есть на экранах, описать из каких блоков состоит слои, из как строятся блоки и тайлы (из более мелких блоков, картинок или тайлов), так же описать, какие свойства блоков присутствуют в данной игре.
</li>
<li>
Описать, как все элементы (раскладки, списки объектов, экраны, слои, блоки и тайлы) будут загружаться и сохраняться - из ROM-файла, из отдельных файлов (дампов памяти и архивов), из заготовленных картинок или иным способом. Сюда же входит описание компрессии данных при загрузке/сохранении, если это необходимо.
</li>
<li>
Возможно, написать и подключить в конфиге дополнительные плагины-редакторы, которые позволят редактировать специфические для игры параметры уровней, не описываемые схемой блочного редактора.
</li>
</ol>
</p>

<p>
В простых редакторах описание взаимоотношений между элементами и способы загрузки/сохранения данных жёстко вшиты в код редактора, а указания адресов загрузки могут использоваться файлы настроек, являющиеся простыми текстовыми (например, формата ini или xml) файлами. Для универсального редактора необходимо иметь возможность задавать произвольный код загрузки/сохранения элементов, а также описания их взаимоотношений с помошью языка программирования (возможно, с элементами DSL), потому что не существует универсального формата, в которой можно было бы сохранить карту произвольной игры.
</p>

<p>
В <b>CadEditor</b> для описания конфигурационных файлов используются библиотека <a href="http://csscript.net/">CSScript</a>, которая позволяет динамически загружать и выполнять скрипты на языке C#. Сам редактор предоставляет библиотеку стандартных функций сохранения/загрузки. Во время загрузки конфигурационного файла редактор ищет в нём функции с заранее определёнными именами, и если они присутствуют, то вызывает их, чтобы построить схему формата уровня конкретной игры, и загрузить данные, позволяющие приступить к редактированию игры. Некоторые функции в конфигурационном файле можно пропустить - в этом случае редактор будет использовать "стандартные" версии функций из своей библиотеки (стандартными выбраны функции, используемые для загрузки уровня из движка Capcom для NES, которые используются для игр <b>Chip & Dale Rescue Rangers, Darkwing Duck, Little Mermaid, Tale Spin, Mega Man 3-6</b> и некоторых других).
</p>

<p>
В следующих статьях будет описан разбор формата уровней нескольких игр и приведены примеры того, как редактор загружает конфиги, созданные для этих игр.
</p>

<p>
Потенциально, возможно создание специальной программы для разработки конфигов новых игр для редактора, с возможностью выбора готовых функций сохранения/загрузки данных и одного из готовых уже описанных форматов уровней (т.к. описаны конфиги примерно 100 игр, скорее всего, найдётся игра, в которой формат уровней будет похож на уже описанные игры), а также написание кода для загрузки данных новыми способами.
</p>

<p>
Однако сейчас конфиги могут быть составлены только в обычном текстовом редакторе с подсветкой синтаксиса языка C#. Для проверки конфига на наличие синтаксических ошибок и присутствия в нём всех необходимых функций, можно просто загрузить его в редактор CadEditor и в случае ошибки в коде конфига получить сообщение с описанием причины и строчки, в которой возникла ошибка (в случае успешной загрузки редактор покажет, как выглядит уровень игры после загрузки его по правилам, описанным в конфиге).
</p>

<p>
Для упрощения проверки всех конфигов в репозитории редактора CadEditor имеются 2 программы - <b>SettingsVerifier</b> и <b>ConfigViewer.</b>
</p>

<p>
<b>SettingsVerifier</b> при запуске автоматически загружает в CadEditor все найденные в текущей папке конфиги и выдаёт на консоль результат - были ли ошибки загрузки или же конфиги валидны.
<img src="images/tut3_settings_verifier.png" alt="settings verifier">
</p>

<p>
<b>ConfigViewer</b> позволяет загрузить конфиг и показывает все имена функций, которые ищет в нём редактор CadEditor, а также позволяет запустить каждую из этих функций конфига отдельно, и показывает результат её выполнения, либо сообщает о том, что при выполнении функции произошла ошибка и сообщает детали этой ошибки.
<img src="images/tut3_config_viewer.png" alt="settings verifier">
</p>

<p>
Разбору формата уровней конкретных игр и способам составления конфигов для них будут посвящены следующие несколько статей.
</p>

  </section>
  </div>
  
   <div class="dashed">
   <div class="container" align="center">
   <a href="index.html" align="right">Назад</a>
   </div>
   </div>
  </body>
</html>
